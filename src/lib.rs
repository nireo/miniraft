use anyhow::anyhow;
use std::{
    collections::HashMap,
    sync::{
        Arc,
        atomic::{AtomicUsize, Ordering},
    },
};
use tarpc::{client, context, tokio_serde::formats::Json};

use tokio::time::{Duration, Instant, interval};

type NodeId = i64;

#[derive(Debug, Clone)]
struct LogEntry {
    command: Vec<u8>,
    term: usize,
}

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
enum NodeState {
    Follower,
    Candidate,
    Leader,
    Dead,
}

#[derive(Debug)]
struct VolatileState {
    state: NodeState,
    election_reset_event: Instant,
}

impl VolatileState {
    fn is_dead(&self) -> bool {
        self.state == NodeState::Dead
    }
}

#[derive(Debug)]
struct PersistentState {
    current_term: usize,
    voted_for: NodeId,
    log: Vec<LogEntry>,
}

#[derive(Debug)]
struct NodeInnerState {
    vol_state: VolatileState,
    persistent_state: PersistentState,
}

#[derive(Debug)]
struct Node {
    id: NodeId,
    peers: Vec<NodeId>,
    inner: tokio::sync::Mutex<NodeInnerState>,
    peer_clients: HashMap<NodeId, RaftClient>,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
struct RequestVoteArgs {
    term: usize,
    last_log_idx: usize,
    last_log_term: usize,
    candidate_id: NodeId,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
struct RequestVoteReply {
    term: usize,
    vote_granted: bool,
}

#[tarpc::service]
trait Raft {
    async fn request_vote(req: RequestVoteArgs) -> RequestVoteReply;
}

impl Raft for Arc<Node> {
    async fn request_vote(
        self,
        context: tarpc::context::Context,
        req: RequestVoteArgs,
    ) -> RequestVoteReply {
        let mut st = self.inner.lock().await;

        if st.vol_state.is_dead() {
            return RequestVoteReply {
                term: st.persistent_state.current_term,
                vote_granted: false,
            };
        }

        if req.term > st.persistent_state.current_term {
            drop(st);
            Arc::clone(&self).become_follower(req.term).await;
            st = self.inner.lock().await;
        }

        let mut transport = tarpc::serde_transport::tcp::connect("127.0.0.1", Json::default);
        transport.config_mut().max_frame_length(usize::MAX);

        // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
        // config and any Transport as input.
        let client = RaftClient::new(client::Config::default(), transport.await.unwrap()).spawn();

        if st.persistent_state.current_term == req.term
            && (st.persistent_state.voted_for == -1
                || st.persistent_state.voted_for == req.candidate_id)
        {
            st.vol_state.election_reset_event = Instant::now();
            RequestVoteReply {
                term: st.persistent_state.current_term,
                vote_granted: true,
            }
        } else {
            RequestVoteReply {
                term: st.persistent_state.current_term,
                vote_granted: false,
            }
        }
    }
}

impl Node {
    async fn stop(&self) {
        let mut inner = self.inner.lock().await;
        inner.vol_state.state = NodeState::Dead;
    }

    fn election_timeout(&self) -> Duration {
        Duration::from_millis(150)
    }

    async fn run_election_timer(self: Arc<Self>) {
        let timeout_duration = self.election_timeout();
        let mut interval = interval(Duration::from_millis(10));
        let start_term;
        {
            let inner = self.inner.lock().await;
            start_term = inner.persistent_state.current_term;
        }

        loop {
            interval.tick().await;

            let inner = self.inner.lock().await;
            if inner.vol_state.state != NodeState::Candidate
                && inner.vol_state.state != NodeState::Follower
            {
                return;
            }

            if start_term != inner.persistent_state.current_term {
                return;
            }

            if inner.vol_state.election_reset_event.elapsed() >= timeout_duration {
                drop(inner);
                self.start_election().await;
                return;
            }
        }
    }

    async fn become_follower(self: Arc<Self>, term: usize) {
        let mut inner = self.inner.lock().await;
        inner.vol_state.state = NodeState::Follower;
        inner.persistent_state.current_term = term;
        inner.persistent_state.voted_for = -1;
        inner.vol_state.election_reset_event = Instant::now();
        tokio::spawn(Arc::clone(&self).run_election_timer());
    }

    async fn start_election(self: Arc<Self>) {
        let mut inner = self.inner.lock().await;
        inner.persistent_state.current_term += 1;

        let saved_term = inner.persistent_state.current_term;
        inner.vol_state.election_reset_event = Instant::now();
        inner.persistent_state.voted_for = self.id;

        let votes_received = Arc::new(AtomicUsize::new(1));

        let peer_ids = self.peers.clone();
        let majority = (peer_ids.len() / 2) + 1;

        for peer in peer_ids {
            let node_clone = Arc::clone(&self);
            let votes_clone = Arc::clone(&votes_received);

            tokio::spawn(async move {
                let args = RequestVoteArgs {
                    term: saved_term,
                    candidate_id: self.id,
                    last_log_term: 0,
                    last_log_idx: 0,
                };

                if let Some(client) = node_clone.peer_clients.get(&peer) {
                    let client = client.clone();

                    let rpc_result: Result<RequestVoteReply, anyhow::Error> = async {
                        let mut context = context::current();
                        context.deadline = std::time::Instant::now() + Duration::from_millis(100); // Timeout
                        client.request_vote(context, args).await.map_err(|e| {
                            anyhow!("RPC call using client for peer {} failed: {}", peer, e)
                        })
                    }
                    .await;

                    match rpc_result {
                        Ok(reply) => {
                            // Acquire lock *inside the task* to process reply
                            let mut inner_guard = node_clone.inner.lock().await;

                            // (Checks: still candidate?, higher term?, vote granted?, majority?)
                            // ... (rest of the reply handling logic - same as before) ...
                            if inner_guard.vol_state.state != NodeState::Candidate {
                                return;
                            } // Check state
                            if reply.term > saved_term {
                                drop(inner_guard);
                                Arc::clone(&node_clone).become_follower(reply.term).await;
                                return;
                            } // Check term
                            if reply.term == saved_term && reply.vote_granted {
                                // Check vote
                                let current_votes = votes_clone.fetch_add(1, Ordering::SeqCst) + 1;
                                if current_votes >= majority {
                                    if inner_guard.vol_state.state == NodeState::Candidate {
                                        drop(inner_guard);
                                        Arc::clone(&node_clone).start_leader().await;
                                        return;
                                    }
                                }
                            }
                        }
                        Err(e) => {}
                    }
                } else {
                }
            });
        }
    }
}
